/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PaperNoteFillerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// english-stopwords.ts
var stopwords = /* @__PURE__ */ new Set([
  "a",
  "a's",
  "able",
  "about",
  "above",
  "according",
  "accordingly",
  "across",
  "actually",
  "after",
  "afterwards",
  "again",
  "against",
  "ain't",
  "all",
  "allow",
  "allows",
  "almost",
  "alone",
  "along",
  "already",
  "also",
  "although",
  "always",
  "am",
  "among",
  "amongst",
  "an",
  "and",
  "another",
  "any",
  "anybody",
  "anyhow",
  "anyone",
  "anything",
  "anyway",
  "anyways",
  "anywhere",
  "apart",
  "appear",
  "appreciate",
  "appropriate",
  "are",
  "aren't",
  "around",
  "as",
  "aside",
  "ask",
  "asking",
  "associated",
  "at",
  "available",
  "away",
  "awfully",
  "b",
  "be",
  "became",
  "because",
  "become",
  "becomes",
  "becoming",
  "been",
  "before",
  "beforehand",
  "behind",
  "being",
  "believe",
  "below",
  "beside",
  "besides",
  "best",
  "better",
  "between",
  "beyond",
  "both",
  "brief",
  "but",
  "by",
  "c",
  "c'mon",
  "c's",
  "came",
  "can",
  "can't",
  "cannot",
  "cant",
  "cause",
  "causes",
  "certain",
  "certainly",
  "changes",
  "clearly",
  "co",
  "com",
  "come",
  "comes",
  "concerning",
  "consequently",
  "consider",
  "considering",
  "contain",
  "containing",
  "contains",
  "corresponding",
  "could",
  "couldn't",
  "course",
  "currently",
  "d",
  "definitely",
  "described",
  "despite",
  "did",
  "didn't",
  "different",
  "do",
  "does",
  "doesn't",
  "doing",
  "don't",
  "done",
  "down",
  "downwards",
  "during",
  "e",
  "each",
  "edu",
  "eg",
  "eight",
  "either",
  "else",
  "elsewhere",
  "enough",
  "entirely",
  "especially",
  "et",
  "etc",
  "even",
  "ever",
  "everybody",
  "everyone",
  "everything",
  "everywhere",
  "ex",
  "exactly",
  "example",
  "except",
  "f",
  "far",
  "few",
  "followed",
  "following",
  "follows",
  "for",
  "former",
  "formerly",
  "forth",
  "four",
  "from",
  "further",
  "furthermore",
  "g",
  "get",
  "gets",
  "getting",
  "given",
  "gives",
  "go",
  "goes",
  "going",
  "gone",
  "got",
  "gotten",
  "greetings",
  "h",
  "had",
  "hadn't",
  "happens",
  "hardly",
  "has",
  "hasn't",
  "have",
  "haven't",
  "having",
  "he",
  "he's",
  "hello",
  "help",
  "hence",
  "her",
  "here",
  "here's",
  "hereafter",
  "hereby",
  "herein",
  "hereupon",
  "hers",
  "herself",
  "hi",
  "him",
  "himself",
  "his",
  "hither",
  "hopefully",
  "how",
  "howbeit",
  "however",
  "i",
  "i'd",
  "i'll",
  "i'm",
  "i've",
  "ie",
  "if",
  "ignored",
  "immediate",
  "in",
  "inasmuch",
  "inc",
  "indeed",
  "indicate",
  "indicated",
  "indicates",
  "inner",
  "insofar",
  "instead",
  "into",
  "inward",
  "is",
  "isn't",
  "it",
  "it'd",
  "it'll",
  "it's",
  "its",
  "itself",
  "j",
  "just",
  "k",
  "keep",
  "keeps",
  "kept",
  "know",
  "known",
  "knows",
  "l",
  "last",
  "lately",
  "later",
  "latter",
  "latterly",
  "least",
  "lest",
  "let",
  "let's",
  "like",
  "liked",
  "likely",
  "look",
  "looking",
  "looks",
  "ltd",
  "m",
  "mainly",
  "many",
  "may",
  "maybe",
  "me",
  "mean",
  "meanwhile",
  "merely",
  "might",
  "more",
  "moreover",
  "most",
  "mostly",
  "much",
  "must",
  "my",
  "myself",
  "n",
  "name",
  "namely",
  "nd",
  "near",
  "nearly",
  "necessary",
  "need",
  "needs",
  "neither",
  "never",
  "nevertheless",
  "new",
  "next",
  "nine",
  "nobody",
  "non",
  "noone",
  "nor",
  "normally",
  "novel",
  "now",
  "nowhere",
  "o",
  "obviously",
  "of",
  "off",
  "often",
  "oh",
  "ok",
  "okay",
  "old",
  "on",
  "once",
  "ones",
  "only",
  "onto",
  "or",
  "other",
  "others",
  "otherwise",
  "ought",
  "our",
  "ours",
  "ourselves",
  "out",
  "outside",
  "over",
  "overall",
  "own",
  "p",
  "particular",
  "particularly",
  "per",
  "perhaps",
  "placed",
  "please",
  "plus",
  "possible",
  "presumably",
  "probably",
  "provides",
  "q",
  "que",
  "quite",
  "qv",
  "r",
  "rather",
  "rd",
  "re",
  "really",
  "reasonably",
  "regarding",
  "regardless",
  "regards",
  "relatively",
  "respectively",
  "right",
  "s",
  "said",
  "same",
  "saw",
  "say",
  "saying",
  "says",
  "secondly",
  "see",
  "seeing",
  "seem",
  "seemed",
  "seeming",
  "seems",
  "seen",
  "self",
  "selves",
  "sensible",
  "sent",
  "serious",
  "seriously",
  "seven",
  "several",
  "shall",
  "she",
  "should",
  "shouldn't",
  "since",
  "so",
  "some",
  "somebody",
  "somehow",
  "someone",
  "something",
  "sometime",
  "sometimes",
  "somewhat",
  "somewhere",
  "soon",
  "sorry",
  "specified",
  "specify",
  "specifying",
  "still",
  "sub",
  "such",
  "sup",
  "sure",
  "t",
  "t's",
  "take",
  "taken",
  "tell",
  "tends",
  "th",
  "than",
  "thank",
  "thanks",
  "thanx",
  "that",
  "that's",
  "thats",
  "the",
  "their",
  "theirs",
  "them",
  "themselves",
  "then",
  "thence",
  "there",
  "there's",
  "thereafter",
  "thereby",
  "therefore",
  "therein",
  "theres",
  "thereupon",
  "these",
  "they",
  "they'd",
  "they'll",
  "they're",
  "they've",
  "think",
  "this",
  "thorough",
  "thoroughly",
  "those",
  "though",
  "three",
  "through",
  "throughout",
  "thru",
  "thus",
  "to",
  "together",
  "too",
  "took",
  "toward",
  "towards",
  "tried",
  "tries",
  "truly",
  "try",
  "trying",
  "u",
  "un",
  "under",
  "unfortunately",
  "unless",
  "unlikely",
  "until",
  "unto",
  "up",
  "upon",
  "us",
  "use",
  "used",
  "useful",
  "uses",
  "using",
  "usually",
  "uucp",
  "v",
  "value",
  "various",
  "very",
  "via",
  "viz",
  "vs",
  "w",
  "want",
  "wants",
  "was",
  "wasn't",
  "way",
  "we",
  "we'd",
  "we'll",
  "we're",
  "we've",
  "welcome",
  "well",
  "went",
  "were",
  "weren't",
  "what",
  "what's",
  "whatever",
  "when",
  "whence",
  "whenever",
  "where",
  "where's",
  "whereafter",
  "whereas",
  "whereby",
  "wherein",
  "whereupon",
  "wherever",
  "whether",
  "which",
  "while",
  "whither",
  "who",
  "who's",
  "whoever",
  "whole",
  "whom",
  "whose",
  "why",
  "will",
  "willing",
  "wish",
  "with",
  "within",
  "won't",
  "wonder",
  "would",
  "wouldn't",
  "x",
  "y",
  "yes",
  "yet",
  "you",
  "you'd",
  "you'll",
  "you're",
  "you've",
  "your",
  "yours",
  "yourself",
  "yourselves",
  "z"
]);

// prompts.ts
var prompts = /* @__PURE__ */ new Map([
  [
    "generateTags",
    `Given a paper abstract and a list of hashtags I have used in the past
        to tag abstracts, select up to five relevant hashtags that best describe 
        the abstract. If none fit, return an empty string. Do not create new hashtags,
        only pick from the list of available hashtags. Return a list of hashtags in
        whitespace delimited form and nothing else.`
  ],
  [
    "futureWork",
    `Given the scientific paper below, succcinctly summarize the avenues for future
        work the authors discuss. No more than 3 sentences in total. Return nothing else.`
  ]
]);

// main.ts
var DEBUG = true;
var path = require("path");
var NAMING_TYPES = [
  "identifier",
  "first-3-title-terms",
  "first-3-title-terms-no-stopwords",
  "first-5-title-terms",
  "first-5-title-terms-no-stopwords",
  "all-title-terms"
];
var DEFAULT_SETTINGS = {
  folderLocation: "",
  fileNaming: NAMING_TYPES[0],
  openAIKey: "N/A",
  openAIModel: "gpt-4o-mini",
  openAIEndpoint: "https://api.openai.com/v1/chat/completions"
};
var STRING_MAP = /* @__PURE__ */ new Map([
  [
    "error",
    "Something went wrong. Check the Obsidian console if the error persists."
  ],
  [
    "openAIError",
    "Something went wrong when querying OpenAI. Check the Obsidian console if the error persists."
  ],
  ["unsupportedUrl", "This URL is not supported. You tried to enter: "],
  [
    "fileAlreadyExists",
    "Unable to create note. File already exists. Opening existing file."
  ],
  ["semanticScholarError", "Error fetching data from Semantic Scholar"],
  ["commandId", "url-to-paper-note"],
  ["commandName", "Create paper note from URL."],
  ["inputLabel1", "Enter a valid URL."],
  ["inputLabel2", "Here are some examples: "],
  ["arXivRestAPI", "https://export.arxiv.org/api/query?id_list="],
  ["aclAnthologyUrlExample", "https://aclanthology.org/2022.acl-long.1/"],
  ["arXivUrlExample", "https://arxiv.org/abs/0000.00000"],
  ["semanticScholarUrlExample", "https://www.semanticscholar.org/paper/some-text/0000.00000"],
  ["inputPlaceholder", "https://my-url.com"],
  ["arxivUrlSuffix", "arXiv:"],
  ["aclAnthologyUrlSuffix", "ACL:"],
  ["semanticScholarFields", "fields=authors,title,abstract,url,venue,year,publicationDate,externalIds"],
  ["semanticScholarAPI", "https://api.semanticscholar.org/graph/v1/paper/"],
  ["settingHeader", "Settings to create paper notes."],
  ["settingFolderName", "Folder"],
  ["settingFolderDesc", "Folder to create paper notes in."],
  ["settingFolderRoot", "(root of the vault)"],
  ["settingNoteName", "Note naming"],
  ["settingNoteDesc", "Method to name the note."],
  ["settingOpenAIName", "OpenAI key"],
  ["settingOpenAIDesc", `Provide a valid OpenAI key for LLM integration, otherwise use '${DEFAULT_SETTINGS.openAIKey}'.`],
  ["settingOpenAIModelName", "OpenAI model name"],
  ["settingOpenAIModelDesc", "Provide the name of an OpenAI model suitable for chat completion, e.g. gpt-4o-mini."],
  ["settingOpenAIEndpointName", "OpenAI chat endpoint"],
  ["settingOpenAIEndpointDesc", "Provide a valid OpenAI chat completion endpoint, e.g. https://api.openai.com/v1/chat/completions."],
  ["noticeRetrievingArxiv", "Retrieving paper information from arXiv API."],
  ["noticeRetrievingSS", "Retrieving paper information from Semantic Scholar API."],
  ["llmMarker", "\u{1F4BB}"]
]);
function trimString(str) {
  if (str == null) return "";
  return str.replace(/\s+/g, " ").trim();
}
var PaperNoteFillerPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: STRING_MAP.get("commandId"),
      name: STRING_MAP.get("commandName"),
      callback: () => {
        new urlModal(this.app, this.settings).open();
      }
    });
    this.addSettingTab(new SettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var urlModal = class extends import_obsidian.Modal {
  constructor(app, settings) {
    super(app);
    this.settings = settings;
  }
  addTextElementToModal(type, value) {
    const { contentEl } = this;
    contentEl.createEl(type, { text: value });
  }
  addInputElementToModal(type) {
    const { contentEl } = this;
    let input = contentEl.createEl(type);
    return input;
  }
  addPropertyToElement(element, property, value) {
    element.setAttribute(property, value);
  }
  getIdentifierFromUrl(url) {
    if (url.endsWith("/"))
      url = url.slice(0, -1);
    return url.split("/").slice(-1)[0];
  }
  //generic prompting of OpenAI model(s)
  async fetchOpenAICompletion(prompt) {
    const payload = {
      model: this.settings.openAIModel,
      messages: [{ role: "user", content: prompt }],
      temperature: 0
      //no uncertainty
    };
    const response = await fetch(this.settings.openAIEndpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.settings.openAIKey}`
      },
      body: JSON.stringify(payload)
    });
    if (!response.ok) {
      throw new Error(`Error ${response.status}: ${response.statusText}`);
    }
    const data = await response.json();
    return data.choices[0].message.content;
  }
  query_llm() {
    if (this.settings.openAIKey == DEFAULT_SETTINGS.openAIKey) {
      return false;
    }
    return true;
  }
  extractFutureWork(paper) {
    if (this.query_llm() == false) {
      return Promise.resolve("");
    }
    const future_prompt = `${prompts.get("futureWork")}

Paper: ${paper}`;
    return this.fetchOpenAICompletion(future_prompt).catch((error) => {
      new import_obsidian.Notice(STRING_MAP.get("openAIError"));
      console.log(error);
      return "";
    });
  }
  generateTagsFromAbstract(abstract) {
    if (this.query_llm() == false) {
      return Promise.resolve("");
    }
    const availableTags = this.app.metadataCache.getTags();
    const tagsString = Object.keys(availableTags).join(" ");
    const tag_prompt = `${prompts.get("generateTags")}

Abstract: ${abstract}

Available hashtags: ${tagsString}`;
    return this.fetchOpenAICompletion(tag_prompt).catch((error) => {
      new import_obsidian.Notice(STRING_MAP.get("openAIError"));
      console.log(error);
      return "";
    });
  }
  extractFileNameFromUrl(url, title) {
    let filename = this.getIdentifierFromUrl(url);
    if (this.settings.fileNaming !== "identifier" && title != null) {
      let sliceEnd = void 0;
      if (this.settings.fileNaming.includes(
        "first-3-title-terms"
      ))
        sliceEnd = 3;
      else if (this.settings.fileNaming.includes(
        "first-5-title-terms"
      ))
        sliceEnd = 5;
      else
        ;
      filename = title.split(" ").filter(
        (word) => !stopwords.has(word.toLowerCase()) || !this.settings.fileNaming.includes(
          "no-stopwords"
        )
      ).slice(0, sliceEnd).join(" ").replace(/[^a-zA-Z0-9 ]/g, "");
    }
    return filename;
  }
  async generateNoteContent(pathToFile, title, authorString, url, htmlData, venue, publicationDate, abstract) {
    if (await this.app.vault.adapter.exists(pathToFile)) {
      new import_obsidian.Notice(STRING_MAP.get("fileAlreadyExists"));
      this.app.workspace.openLinkText(pathToFile, pathToFile);
      return;
    }
    let tags = await this.generateTagsFromAbstract(abstract);
    if (tags.length >= 3) {
      tags = `${STRING_MAP.get("llmMarker")} ${tags}`;
    }
    let futureWork = "";
    if (htmlData.length > 50) {
      futureWork = await this.extractFutureWork(htmlData);
    }
    if (futureWork.length >= 10) {
      futureWork = `${STRING_MAP.get("llmMarker")} ${futureWork}`;
    }
    await this.app.vault.create(
      pathToFile,
      "---\ntags: \nlink: " + url + "\nauthors: " + trimString(authorString) + "\ndate: " + trimString(publicationDate) + "\n---\n"  + "\n## Abstract\n" + trimString(abstract) 
    );
    await this.app.workspace.openLinkText(pathToFile, pathToFile);
  }
  parseMetadataFromSemanticScholar(data) {
    const json = JSON.parse(data);
    if (json.error) {
      throw new Error(STRING_MAP.get("semanticScholarError"));
    }
    const title = json.title || "undefined";
    const abstract = json.abstract || "";
    const authors = json.authors.map((author) => author.name).join(", ");
    const venue = json.venue ? `${json.venue} ${json.year}` : "";
    const publicationDate = json.publicationDate || "";
    const url = json.url;
    return { title, authorString: authors, venue, publicationDate, abstract, url };
  }
  extractFromSemanticScholar(url) {
    const id = this.getIdentifierFromUrl(url);
    const suffix = url.includes("arxiv") ? STRING_MAP.get("arxivUrlSuffix") : url.includes("aclanthology") ? STRING_MAP.get("aclAnthologyUrlSuffix") : "";
    if (suffix === "") {
      new import_obsidian.Notice(STRING_MAP.get("unsupportedUrl") + url);
      return;
    }
    const htmlData = "";
    fetch(`${STRING_MAP.get("semanticScholarAPI")}${suffix}${id}?${STRING_MAP.get("semanticScholarFields")}`).then((response) => response.text()).then((data) => {
      const { title, authorString, venue, publicationDate, abstract, url: url2 } = this.parseMetadataFromSemanticScholar(data);
      const filename = this.extractFileNameFromUrl(url2, title);
      const pathToFile = `${this.settings.folderLocation}${path.sep}${filename}.md`;
      this.generateNoteContent(pathToFile, title, authorString, url2, htmlData, venue, publicationDate, abstract);
    }).catch((error) => {
      new import_obsidian.Notice(STRING_MAP.get("error"));
      console.error(error);
    }).finally(() => {
      this.close();
    });
  }
  extractFromArxiv(url) {
    const id = this.getIdentifierFromUrl(url);
    fetch(STRING_MAP.get("arXivRestAPI") + id).then((response) => response.text()).then((data) => {
      var _a, _b, _c, _d;
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(data, "text/xml");
      const title = ((_a = xmlDoc.getElementsByTagName("title")[1]) == null ? void 0 : _a.textContent) || "undefined";
      const abstract = ((_b = xmlDoc.getElementsByTagName("summary")[0]) == null ? void 0 : _b.textContent) || "";
      const authors = Array.from(xmlDoc.getElementsByTagName("author")).map(
        (author) => {
          var _a2;
          return ((_a2 = author.getElementsByTagName("name")[0]) == null ? void 0 : _a2.textContent) || "";
        }
      ).join(", ");
      const publicationDate = ((_d = (_c = xmlDoc.getElementsByTagName("published")[0]) == null ? void 0 : _c.textContent) == null ? void 0 : _d.split("T")[0]) || "";
      const filename = this.extractFileNameFromUrl(url, title);
      const pathToFile = `${this.settings.folderLocation}${path.sep}${filename}.md`;
      const venue = "";
      const urlHtmlVersion = url.replace("/abs/", "/html/") + "v1";
      let htmlData = "";
      return (0, import_obsidian.requestUrl)(urlHtmlVersion).then((htmlResponse) => {
        const buffer = htmlResponse.arrayBuffer;
        const decoder = new TextDecoder("utf-8");
        htmlData = decoder.decode(buffer);
        const htmlParser = new DOMParser();
        const htmlDoc = htmlParser.parseFromString(htmlData, "text/html");
        htmlData = htmlDoc.body.textContent || "";
        if (DEBUG == true) {
          console.log(htmlData);
        }
      }).catch((htmlError) => {
        console.log(htmlError);
        htmlData = "";
      }).finally(() => {
        this.generateNoteContent(pathToFile, title, authors, url, htmlData, venue, publicationDate, abstract);
        this.close();
      });
    }).catch((error) => {
      console.error("Error fetching arXiv metadata:", error);
    });
  }
  onOpen() {
    const { contentEl } = this;
    this.addTextElementToModal("h2", STRING_MAP.get("inputLabel1"));
    this.addTextElementToModal("p", STRING_MAP.get("inputLabel2"));
    this.addTextElementToModal("p", STRING_MAP.get("aclAnthologyUrlExample"));
    this.addTextElementToModal("p", STRING_MAP.get("arXivUrlExample"));
    this.addTextElementToModal("p", STRING_MAP.get("semanticScholarUrlExample"));
    let input = this.addInputElementToModal("input");
    this.addPropertyToElement(input, "type", "search");
    this.addPropertyToElement(input, "placeholder", STRING_MAP.get("inputPlaceholder"));
    this.addPropertyToElement(input, "minLength", STRING_MAP.get("inputPlaceholder"));
    this.addPropertyToElement(input, "style", "width: 75%;");
    let extracting = false;
    contentEl.addEventListener("keydown", (event) => {
      if (event.key !== "Enter") return;
      let url = input.value.trim().toLowerCase();
      if (!extracting) {
        extracting = true;
        if (DEBUG == true) {
          console.log("HTTP request: " + url);
        }
        if (url.includes("arxiv.org")) {
          new import_obsidian.Notice(STRING_MAP.get("noticeRetrievingArxiv"));
          this.extractFromArxiv(url);
        } else {
          new import_obsidian.Notice(STRING_MAP.get("noticeRetrievingSS"));
          this.extractFromSemanticScholar(url);
        }
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", {
      text: STRING_MAP.get("settings")
    });
    let folders = this.app.vault.getFiles().map(
      (file) => {
        let parts = file.path.split(path.sep);
        parts.pop();
        let res = [];
        for (let i = 0; i < parts.length; i++) {
          res.push(parts.slice(0, i + 1).join(path.sep));
        }
        return res;
      }
    ).flat().filter((folder, index, self) => self.indexOf(folder) === index);
    let folderOptions = {};
    folders.forEach((record) => {
      folderOptions[record] = record;
    });
    folderOptions[""] = STRING_MAP.get("settingFolderRoot");
    new import_obsidian.Setting(containerEl).setName(STRING_MAP.get("settingFolderName")).setDesc(STRING_MAP.get("settingFolderDesc")).addDropdown(
      (dropdown) => dropdown.addOptions(folderOptions).setValue(this.plugin.settings.folderLocation).onChange(async (value) => {
        this.plugin.settings.folderLocation = value;
        await this.plugin.saveSettings();
      })
    );
    let namingOptions = {};
    NAMING_TYPES.forEach((record) => {
      namingOptions[record] = record;
    });
    new import_obsidian.Setting(containerEl).setName(STRING_MAP.get("settingNoteName")).setDesc(STRING_MAP.get("settingNoteDesc")).addDropdown(
      (dropdown) => dropdown.addOptions(namingOptions).setValue(this.plugin.settings.fileNaming).onChange(async (value) => {
        this.plugin.settings.fileNaming = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName(STRING_MAP.get("settingOpenAIName")).setDesc(STRING_MAP.get("settingOpenAIDesc")).addText(
      (text) => text.setValue(this.plugin.settings.openAIKey).onChange(async (value) => {
        this.plugin.settings.openAIKey = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName(STRING_MAP.get("settingOpenAIModelName")).setDesc(STRING_MAP.get("settingOpenAIModelDesc")).addText(
      (text) => text.setValue(this.plugin.settings.openAIModel).onChange(async (value) => {
        this.plugin.settings.openAIModel = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName(STRING_MAP.get("settingOpenAIEndpointName")).setDesc(STRING_MAP.get("settingOpenAIEndpointDesc")).addText(
      (text) => text.setValue(this.plugin.settings.openAIEndpoint).onChange(async (value) => {
        this.plugin.settings.openAIEndpoint = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
